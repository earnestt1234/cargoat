<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>cargoat.sim API documentation</title>
<meta name="description" content="Module for the cargoat `MontyHallSimulation` class, which is used for
running a given Monty Hall experiment many times." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cargoat.sim</code></h1>
</header>
<section id="section-intro">
<p>Module for the cargoat <code>MontyHallSimulation</code> class, which is used for
running a given Monty Hall experiment many times.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
&#34;&#34;&#34;
Module for the cargoat `MontyHallSimulation` class, which is used for
running a given Monty Hall experiment many times.
&#34;&#34;&#34;

import warnings

import numpy as np

from cargoat.arrayops import get_index_success
from cargoat.errors import (
    BadCar,
    BadPick,
    BadReveal,
    bad_trials_raise,
    check_n_per_row,
    check_redundancy_for_setting
    )

def combine_sims(sims, index=None, copy=True):
    &#39;&#39;&#39;
    Merge two or more simulations together, by stacking their
    trials together.

    Parameters
    ----------
    sims : list-like
        Collection of MontyHallSims.
    index : list-like, optional
        Indexer used to direct the merging of simulations. The default is None,
        in which case the simulation trials are concatenated in the order
        passed.

        `index` can be used to determine the order of rows for stitching
        together simulations.  The values of `index` should be integers
        in `range(len(sims))`, and each value *i* should appear as many times
        as the number of rows in the *ith* simulation.  Thus the length of
        `index` should be equal to the total number of trials across
        all simulations passed.

        See examples below.

    copy : bool, optional
        Explicitly copy the arrays of the simulation before creating the
        new simulation. The default is True.

    Raises
    ------
    ValueError
        Different number of doors between simulations, or index does not
        match total number of trials.

    Returns
    -------
    MontyHallSim
        New merged simulation object.

    Examples
    -------

    ```python
    &gt;&gt;&gt; import cargoat as cg
    &gt;&gt;&gt; game = [cg.InitDoorsRandom(cars=1, goats=2), cg.Pick(3)]
    &gt;&gt;&gt; a = cg.play(game, n=3)
    &gt;&gt;&gt; b = cg.play(game[:1], n=3)

    &gt;&gt;&gt; a.picked
    array([[1, 1, 1],
           [1, 1, 1],
           [1, 1, 1]])

    &gt;&gt;&gt; b.picked
    array([[0, 0, 0],
           [0, 0, 0],
           [0, 0, 0]])

    # simple concatenation
    &gt;&gt;&gt; c = cg.combine_sims([a, b])
    &gt;&gt;&gt; type(c)
    cargoat.sim.MontyHallSim

    &gt;&gt;&gt; c.picked
    array([[1, 1, 1],
           [1, 1, 1],
           [1, 1, 1],
           [0, 0, 0],
           [0, 0, 0],
           [0, 0, 0]])

    # using index to interleave
    &gt;&gt;&gt; index = [0, 1, 0, 1, 0, 1]
    &gt;&gt;&gt; d = cg.combine_sims([a, b], index=index)
    &gt;&gt;&gt; d.picked
    array([[1, 1, 1],
           [0, 0, 0],
           [1, 1, 1],
           [0, 0, 0],
           [1, 1, 1],
           [0, 0, 0]])

    ```

    &#39;&#39;&#39;

    n = len(sims)
    rows = [x.shape[0] for x in sims]
    cols = [x.shape[1] for x in sims if not x.empty]
    copyfun = (lambda x: x.copy()) if copy else (lambda x: x)

    if len(set(cols)) != 1:
        raise ValueError(&#39;All sims must have the same number of doors (columns).&#39;)

    if index is None:
        index = np.repeat(np.arange(n, dtype=int), rows)

    if len(index) != sum(rows):
        raise ValueError(&#39;Index length must match number of trials across simulations.&#39;)

    shape = (len(index), cols[0])

    cars = np.zeros(shape, dtype=int)
    picked = np.zeros(shape, dtype=int)
    revealed = np.zeros(shape, dtype=int)
    spoiled = np.zeros(shape[0], dtype=bool)

    for i in np.unique(index):
        sim = sims[i]
        cars[index == i, :] = copyfun(sim.cars)
        picked[index == i, :] = copyfun(sim.picked)
        revealed[index == i, :] = copyfun(sim.revealed)
        spoiled[index == i] = sim.spoiled

    return MontyHallSim.from_arrays(picked=picked,
                                    revealed=revealed,
                                    cars=cars,
                                    spoiled=spoiled,
                                    copy=False)

class MontyHallSim:
    &#39;&#39;&#39;Class for remembering the status of the game simualtion.&#39;&#39;&#39;

    # ---- Dunder methods

    def __init__(self, n):
        &#39;&#39;&#39;
        The MontyHallSim object tracks the game status for repeated Monty Hall
        games.

        Games are mainly recorded with numpy arrays.  There are three primary
        arrays, stored as attributes:
            - `self.picked`: Indicates doors selected by the player
            - `self.revealed`: Indicates doors that have been opened
            - `self.cars`: Indicates doors which have a car behind them.

        These are all binary, 2D, integer arrays.  The shape of the arrays
        during/after a typical simulation will be (trials, doors) - one row
        constitutes one game.  The initialization argument `n` determines
        the number of trials.  The number of doors is determined by the particular
        game being played.

        There is also a `spoiled` attribute, which is a boolean numpy array of
        shape (trials,).  This simply records whether a trial has broken
        the rules of the traditional Monty Hall game.

        MontyHallSims are updated by applying rules/actions, i.e. from the
        `cargoat.actions` subpackage.

        Typically, a user *should not* have to manually define a MontyHallSim
        object, as `cargoat.core.play` will do this provided a list of actions.
        *Initialization of a MontyHallSim results in an empty simulation* -
        i.e. all the array attributes will be empty.  The actions in
        `cargoat.actions.initialization` are intended for populating the
        simulation.


        Parameters
        ----------
        n : int
            Number of trials to simulate.

        Returns
        -------
        None.

        &#39;&#39;&#39;
        self.n = int(n)

        self.make_empty()

    def __eq__(self, sim):
        if not isinstance(sim, MontyHallSim):
            return False
        elif self.shape != sim.shape:
            return False
        else:
            return all([(self.cars == sim.cars).all(),
                        (self.picked == sim.picked).all(),
                        (self.revealed == sim.revealed).all(),
                        (self.spoiled == sim.spoiled).all(),
                        (self.n == sim.n)])

    # ---- Class methods

    @classmethod
    def from_arrays(cls, picked=None, revealed=None, cars=None,
                    spoiled=None, default=0, copy=True):
        &#39;&#39;&#39;
        Construct a MontyHallSim from existing numpy arrays.

        Parameters
        ----------
        picked : 2D numpy array, optional
            Integer array indicating picked doors. The default is None.
        revealed : 2D numpy array, optional
            Integer array indicating revealed doors. The default is None.
        cars : 2D numpy array, optional
            Integer array indicating doors containing cars. The default is None.
        spoiled : 1D numpy array, optional
            Boolean array indicating spoiled trials. The default is None.
        default : int, optional
            When only some of `picked`/`revealed`/`cars` are provided, use
            this value to fill the missing arrays. The default is 0.
        copy : bool, optional
            Call an explicit copy on the arrays before binding to the new
            simulation being created. Intended to prevent multiple simulations
            pointing to the same arrays.  The default is True.

        Raises
        ------
        ValueError
            - Didn&#39;t provide at least one of `cars`, `picked`, or `revealed`
            - Different array shapes for provided arrays.

        Returns
        -------
        out : MontyHallSim
            New simulation object.

        &#39;&#39;&#39;

        mainarrays = (cars, picked, revealed)

        if all([i is None for i in mainarrays]):
            raise ValueError(&#39;Must provide at least one of cars, &#39;
                             &#39;picked, or revealed.&#39;)

        base = [a for a in mainarrays if a is not None][0]
        shape = base.shape

        if picked is None:
            picked = np.full(shape, default)
        if revealed is None:
            revealed = np.full(shape, default)
        if cars is None:
            cars = np.full(shape, default)

        shape_set = set(i.shape for i in (cars, picked, revealed))

        if len(shape_set) != 1:
            raise ValueError(&#39;Detected different array shapes for &#39;
                             &#39;picked, revealed, and cars.&#39;)

        n, doors = shape
        if spoiled is None:
            spoiled = np.zeros(n, dtype=bool)
        if len(spoiled) != n:
            raise ValueError(&#39;spoiled array does not match&#39;)

        for a in (cars, picked, revealed, spoiled):
            uniq = np.unique(a)
            if any(u not in (0, 1) for u in uniq):
                msg = (&#34;Non-binary integer detected in incoming arrays.&#34;)
                warnings.warn(RuntimeWarning(msg))

        copyfun = (lambda x: x.copy()) if copy else (lambda x: x)

        out = cls(n)
        out.cars = copyfun(cars)
        out.picked = copyfun(picked)
        out.revealed = copyfun(revealed)
        out.spoiled = copyfun(spoiled)

        return out

    # ---- Properties
    @property
    def idx(self):
        &#39;&#39;&#39;Return a numpy arange of length `self.n`&#39;&#39;&#39;
        return np.arange(self.n)

    @property
    def shape(self):
        &#39;&#39;&#39;Return the dimensions of the simulation (trials, doors).  Throws an error if
        different array shapes are found.&#39;&#39;&#39;
        shape_set = set([self.cars.shape, self.picked.shape, self.revealed.shape])
        if len(shape_set) != 1:
            raise RuntimeError(&#39;Found different shapes for simulation arrays!&#39;)

        return self.picked.shape

    @property
    def empty(self):
        &#39;&#39;&#39;Determine if the sim is &#34;empty&#34; - this is the status it should
        have prior to applying any operations.&#39;&#39;&#39;
        arrs = [self.cars, self.picked, self.revealed, self.spoiled]
        return all(a.size == 0 for a in arrs)


    # ---- Initialization
    def init_doors(self, doors):
        &#39;&#39;&#39;Populate arrays with zeros.&#39;&#39;&#39;
        shape = (self.n, doors)
        self.cars = np.zeros(shape, dtype=int)
        self.picked = np.zeros(shape, dtype=int)
        self.revealed = np.zeros(shape, dtype=int)
        self.spoiled = np.zeros(self.n, dtype=bool)

    def make_empty(self):
        &#39;&#39;&#39;Save empty arrays into main arrays.&#39;&#39;&#39;
        self.cars = np.empty(0, dtype=int)
        self.picked = np.empty(0, dtype=int)
        self.revealed = np.empty(0, dtype=int)
        self.spoiled = np.empty(0, dtype=bool)

    # ---- Indexing
    def select(self, x=None, y=None, copy=True, use_ix_=True):
        &#39;&#39;&#39;
        Index the simulation to create a new one.

        Parameters
        ----------
        x : int, float, list-like, optional
            Indexer for trials (rows) of simulation. The default is None,
            in which case all trials are selected.
        y : int, float, list-like, optional
            Indexer for doors (columns) of simulation. The default is None,
            in which case all doors are selected.
        copy : bool, optional
            Create an explicit copy of the arrays before binding to the
            newly created simulation. The default is True.  Note that
            many indexing operations with this function trigger numpy advanced
            indexing and thus create copies of the main arrays.
            For now, copy is set to default and wastefully create more copies.
            This may be optimized in the future.
        use_ix_ : bool, optional
            Use `np.ix_` when passing `x` and `y`.  This is typically
            necessary for selecting doors and trials simultaneously -
            indexing both rows and columns is not as simple as passing
            `arr[x, y]`.

        Returns
        -------
        MontyHallSimulation
            New simulation object.

        &#39;&#39;&#39;
        # this prevents loss of dimension for selecting single doors
        x = [x] if isinstance(x, int) else x
        y = [y] if isinstance(y, int) else y

        # this allows for selection of trials and doors simulataneously
        if (x is not None and y is not None) and use_ix_:
            x, y = np.ix_(x, y)

        # this allows indexing of only one axis
        x = slice(None) if x is None else x
        y = slice(None) if y is None else y

        copyfun = (lambda x: x.copy()) if copy else (lambda x: x)

        cars = copyfun(self.cars[x, y])
        picked = copyfun(self.picked[x, y])
        revealed = copyfun(self.revealed[x, y])
        spoiled = copyfun(self.spoiled[x])

        return self.from_arrays(picked=picked,
                                revealed=revealed,
                                cars=cars,
                                spoiled=spoiled,
                                copy=False)


    # ---- Status of the sim
    def pickable_doors(self, exclude_current=True):
        &#39;&#39;&#39;Array of the simulation shape indicating which doors are
        not revealed (with or without the current picked doors).&#39;&#39;&#39;
        return ~self.query_doors_or(picked=exclude_current, revealed=True)

    def query_doors_or(self, cars=False, picked=False, revealed=False,
                       not_cars=False, not_picked=False, not_revealed=False):
        &#39;&#39;&#39;
        Return a boolean array indicating which doors of the simulation
        meet one or more conditions.

        Parameters
        ----------
        cars : bool, optional
            Signal doors containing cars. The default is False.
        picked : bool, optional
            Signal doors that are picked. The default is False.
        revealed : bool, optional
            Signal doors that are revealed. The default is False.
        not_cars : bool, optional
            Signal doors that do not contain cars. The default is False.
        not_picked : bool, optional
            Signal doors that are not picked. The default is False.
        not_revealed : bool, optional
            Signal doors that are closed. The default is False.

        Returns
        -------
        out : numpy array

        &#39;&#39;&#39;
        c = int(cars)
        p = int(picked)
        r = int(revealed)
        notc = int(not_cars)
        notp = int(not_picked)
        notr = int(not_revealed)

        out = np.logical_or.reduce([
            c * self.cars,
            p * self.picked,
            r * self.revealed,
            notc * (1 - self.cars),
            notp * (1 - self.picked),
            notr * (1 - self.revealed)
            ])
        return out

    def revealable_doors(self):
        &#39;&#39;&#39;Array of the simulation shape indicating which doors are
        not revealed, don&#39;t contain cars, and aren&#39;t currently picked.&#39;&#39;&#39;
        return ~self.query_doors_or(cars=True, picked=True, revealed=True)

    def count_totals(self, target):
        &#39;&#39;&#39;Return a count of the number of positives for each trial in the
        simulation.  Target is `cars`, `picked`, or `revealed`. &#39;&#39;&#39;
        arr = getattr(self, target)
        return arr.sum(axis=1)

    def show(self, start=0, end=10):
        &#39;&#39;&#39;Printout a representation of a selection of rows of the simulation.&#39;&#39;&#39;
        start = max(0, start)
        end = min(self.n, end)
        print(f&#39;Trials: {start}-{end-1}&#39;)
        print(&#39;\nCars:&#39;)
        print(self.cars[start:end, ])
        print(&#39;\nRevealed:&#39;)
        print(self.revealed[start:end, ])
        print(&#39;\nPicked:&#39;)
        print(self.picked[start:end, ])

    # ---- Generic setter functions

    def _get_spoiling_func(self, target):
        &#39;&#39;&#39;Helper to return the function used to detect spoiled games when
        applying certain actions.&#39;&#39;&#39;
        if target == &#39;picked&#39;:
            return self._check_spoiling_picks

        elif target == &#39;revealed&#39;:
            return self._check_spoiling_reveals

        elif target == &#39;cars&#39;:
            return self._check_spoiling_cars

        else:
            raise ValueError (&#39;Target must be &#34;picked&#34;, &#34;revealed&#34;, or &#34;cars&#34;&#39;)

    def _set_array(self, target, new_array,
                   behavior=&#39;overwrite&#39;, n_per_row=None, allow_spoiled=False,
                   allow_redundant=True):
        &#39;&#39;&#39;
        Main function for altering the cars, picked, and revealed arrays
        of the simulation when applying a action in the game.

        A new array is passed, along with a behavior defining how to
        treat the new array.  This information is used to determine
        how to update the simulation.

        Some optional checks can be applied to verify the settings
        are behaving as expected and that the traditional game rules
        are more/less followed.

        Parameters
        ----------
        target : &#39;cars&#39;, &#39;picked&#39;, or &#39;revealed&#39;
            Simulation array to set.
        new_array : numpy array
            New array to use to update the simulation
        behavior : &#39;overwrite&#39;, &#39;add&#39;, or &#39;remove&#39;, optional
            How to treat the `new_array`. The default is &#39;overwrite&#39;.
            - overwrite: `new_array` should simply replace the current target array.
            - add: any 1s in `new_array` should be added to any 1s in the current target
            array (essentially an &#34;or&#34; operation)
            - remove: any 1s in `new_array` should indicate places to remove 1s
            in the current array.
        n_per_row : int, optional
            Enforce that a certain number of 1s are present per row in `new_array`.
            The default is None, in which case there is no enforcement. An
            error is raised if the condition is not met.  See
            `cargoat.errors.check_n_per_row()`.
        allow_spoiled : bool, optional
            Allow entries in the new array that &#34;spoil&#34; the game; i.e. break
            the rules of the game. The specific checks are dependent on
            the `target` and the `behavior`.  The default is False.
            If False, spoiled games will raise an error.  If True,
            spoiled games will be marked in the `self.spoiled` attribute.
        allow_redundant : bool, optional
            Allow entries in the new array that are redundant with the
            current simulation, e.g. closing an already closed door or picking
            an already picked door.  The default is True.  If False,
            redundant actions will raise an error.

        Returns
        -------
        None.

        &#39;&#39;&#39;

        old_array = getattr(self, target)
        check_spoiling = self._get_spoiling_func(target)
        etype = {&#39;cars&#39;: BadCar,
                 &#39;revealed&#39;: BadReveal,
                 &#39;picked&#39;: BadPick}[target]

        if new_array.shape != self.shape:
            raise ValueError(f&#39;New array shape {new_array.shape} &#39;
                             f&#39;does not match current shape {self.shape}&#39;)

        # apply checks if requested
        if n_per_row is not None:
            check_n_per_row(a=new_array, n=n_per_row, etype=etype)

        if not allow_redundant:
            check_redundancy_for_setting(old_array=old_array, new_array=new_array,
                                         behavior=behavior, etype=etype)

        # then check for valid action
        kosher = check_spoiling(new_array, behavior=behavior, allow_spoiled=allow_spoiled)

        # mark spoiled games (only based on invalid picks)
        spoiling_rows = np.any(~kosher, axis=1)
        self.spoiled[spoiling_rows] = 1

        # update sim.picked
        if behavior == &#39;add&#39;:
            new_array = np.logical_or(new_array, old_array).astype(int)
        elif behavior == &#39;remove&#39;:
            new_array = old_array - np.logical_and(new_array, old_array).astype(int)
            new_array[new_array &lt; 0] = 0

        setattr(self, target, new_array)

    # ---- Pick setting

    def _check_spoiling_picks(self, picks, behavior, allow_spoiled=True):
        &#39;&#39;&#39;
        Checks if new picks spoil the game. Violations are when
        revealed doors are picked.  Removals (unpicking) do
        not trigger spoiling.
        &#39;&#39;&#39;
        if behavior in [&#39;add&#39;, &#39;overwrite&#39;]:
            valid =  ~ np.logical_and(self.revealed, picks)
        elif behavior == &#39;remove&#39;:
            valid = np.full(self.shape, True)

        if not allow_spoiled and np.any(~valid):
            invalid_rows = np.any(~valid, axis=1)
            trial, door = get_index_success(~valid)
            msg = (&#34;Revealed doors were picked, e.g. &#34;
                   f&#34;trial {trial} door {door}.&#34;)
            bad_trials_raise(invalid_rows, msg, BadPick)

        return valid

    # ---- Door revealing

    def _check_spoiling_reveals(self, reveals, behavior, allow_spoiled=True):
        &#39;&#39;&#39;
        Checks if new reveals spoil the game. Violations are when
        cars or picked foors are revealed.  Removals (closing) do
        not trigger spoiling.
        &#39;&#39;&#39;
        offlimits = self.query_doors_or(cars=True, picked=True)
        if behavior in [&#39;add&#39;, &#39;overwrite&#39;]:
            valid =  ~np.logical_and(offlimits, reveals)
        elif behavior == &#39;remove&#39;:
            valid = np.full(self.shape, True)

        if not allow_spoiled and np.any(~valid):
            invalid_rows = np.any(~valid, axis=1)
            trial, door = get_index_success(~valid)
            msg = (&#34;Cars or picked doors were revealed, e.g. &#34;
                   f&#34;trial {trial} door {door}.&#34;)
            bad_trials_raise(invalid_rows, msg, BadReveal)

        return valid

    # ---- Car placing
    def _check_spoiling_cars(self, cars, behavior, allow_spoiled=True):
        &#39;&#39;&#39;
        Checks if new car placements spoil the game. Car placement/removal
        is not really mentioned in the typical game variations.  For now
        altering the car array does not result in spoiled games.
        &#39;&#39;&#39;
        valid = np.full(self.shape, True)
        return valid

    # ---- Other Helpers
    def apply_func(self, func, inplace=False, cars=True, picked=True, revealed=True):
        &#39;&#39;&#39;
        Apply a function to one or more of the cars, picked, and revealed
        arrays.

        Parameters
        ----------
        func : callable
            Function to apply.
        inplace : bool, optional
            The function will modify the arrays in place. The default is False.
        cars : bool, optional
            Apply to the car array. The default is True.
        picked : bool, optional
            Apply to the picked array. The default is True.
        revealed : bool, optional
            Apply to the revealed array. The default is True.

        Returns
        -------
        None.

        &#39;&#39;&#39;
        apply_to = [x for i, x in enumerate([&#39;cars&#39;, &#39;picked&#39;, &#39;revealed&#39;])
                    if [cars, picked, revealed][i]]
        for attr in apply_to:
            a = getattr(self, attr)
            if inplace:
                func(a)
            else:
                setattr(self, attr, func(a))

    def copy(self):
        &#39;&#39;&#39;
        Create a copy of the current simulation.

        Returns
        -------
        MontyHallSim

        &#39;&#39;&#39;
        if self.empty:
            return MontyHallSim(self.n)
        else:
            return self.from_arrays(picked=self.picked,
                                    revealed=self.revealed,
                                    cars=self.cars,
                                    spoiled=self.spoiled,
                                    copy=True)

    # ---- Results

    def is_win(self):
        &#39;&#39;&#39;
        Return a boolean array indicating which trials are wins.  I.e.,
        at least one door with a car is picked.  Spoiled games have not
        bearing on this method
        &#39;&#39;&#39;
        return np.any(self.picked * self.cars, axis=1)

    def get_results(self, condition=None):
        &#39;&#39;&#39;
        Return a dictionary containing the game results,
        e.g. number of wins and losses.  Trials are counted
        as wins when at least one pick and car overlap, i.e.
        both have 1s in the same position.

        Parameters
        ----------
        condition :  callable or list-like
            A pre-computed 1D boolean arrray used to index the simulation.

        Returns
        -------
        None.

        &#39;&#39;&#39;


        sim = self.select(x=condition) if condition is not None else self

        wins = np.sum(np.any(sim.picked * sim.cars, axis=1))
        losses = sim.n - wins
        percent_wins = (wins / sim.n) * 100
        percent_losses = (losses / sim.n) * 100
        spoiled_games = np.any(sim.spoiled)
        results = {
            &#39;trials&#39;: sim.n,
            &#39;wins&#39;: wins,
            &#39;losses&#39;: losses,
            &#39;percent_wins&#39;: percent_wins,
            &#39;percent_losses&#39;: percent_losses,
            &#39;spoiled_games&#39;: spoiled_games
            }

        return results</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="cargoat.sim.combine_sims"><code class="name flex">
<span>def <span class="ident">combine_sims</span></span>(<span>sims, index=None, copy=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Merge two or more simulations together, by stacking their
trials together.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sims</code></strong> :&ensp;<code>list-like</code></dt>
<dd>Collection of MontyHallSims.</dd>
<dt><strong><code>index</code></strong> :&ensp;<code>list-like</code>, optional</dt>
<dd>
<p>Indexer used to direct the merging of simulations. The default is None,
in which case the simulation trials are concatenated in the order
passed.</p>
<p><code>index</code> can be used to determine the order of rows for stitching
together simulations.
The values of <code>index</code> should be integers
in <code>range(len(sims))</code>, and each value <em>i</em> should appear as many times
as the number of rows in the <em>ith</em> simulation.
Thus the length of
<code>index</code> should be equal to the total number of trials across
all simulations passed.</p>
<p>See examples below.</p>
</dd>
<dt><strong><code>copy</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Explicitly copy the arrays of the simulation before creating the
new simulation. The default is True.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Different number of doors between simulations, or index does not
match total number of trials.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="cargoat.sim.MontyHallSim" href="#cargoat.sim.MontyHallSim">MontyHallSim</a></code></dt>
<dd>New merged simulation object.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">&gt;&gt;&gt; import cargoat as cg
&gt;&gt;&gt; game = [cg.InitDoorsRandom(cars=1, goats=2), cg.Pick(3)]
&gt;&gt;&gt; a = cg.play(game, n=3)
&gt;&gt;&gt; b = cg.play(game[:1], n=3)

&gt;&gt;&gt; a.picked
array([[1, 1, 1],
       [1, 1, 1],
       [1, 1, 1]])

&gt;&gt;&gt; b.picked
array([[0, 0, 0],
       [0, 0, 0],
       [0, 0, 0]])

# simple concatenation
&gt;&gt;&gt; c = cg.combine_sims([a, b])
&gt;&gt;&gt; type(c)
cargoat.sim.MontyHallSim

&gt;&gt;&gt; c.picked
array([[1, 1, 1],
       [1, 1, 1],
       [1, 1, 1],
       [0, 0, 0],
       [0, 0, 0],
       [0, 0, 0]])

# using index to interleave
&gt;&gt;&gt; index = [0, 1, 0, 1, 0, 1]
&gt;&gt;&gt; d = cg.combine_sims([a, b], index=index)
&gt;&gt;&gt; d.picked
array([[1, 1, 1],
       [0, 0, 0],
       [1, 1, 1],
       [0, 0, 0],
       [1, 1, 1],
       [0, 0, 0]])

</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_sims(sims, index=None, copy=True):
    &#39;&#39;&#39;
    Merge two or more simulations together, by stacking their
    trials together.

    Parameters
    ----------
    sims : list-like
        Collection of MontyHallSims.
    index : list-like, optional
        Indexer used to direct the merging of simulations. The default is None,
        in which case the simulation trials are concatenated in the order
        passed.

        `index` can be used to determine the order of rows for stitching
        together simulations.  The values of `index` should be integers
        in `range(len(sims))`, and each value *i* should appear as many times
        as the number of rows in the *ith* simulation.  Thus the length of
        `index` should be equal to the total number of trials across
        all simulations passed.

        See examples below.

    copy : bool, optional
        Explicitly copy the arrays of the simulation before creating the
        new simulation. The default is True.

    Raises
    ------
    ValueError
        Different number of doors between simulations, or index does not
        match total number of trials.

    Returns
    -------
    MontyHallSim
        New merged simulation object.

    Examples
    -------

    ```python
    &gt;&gt;&gt; import cargoat as cg
    &gt;&gt;&gt; game = [cg.InitDoorsRandom(cars=1, goats=2), cg.Pick(3)]
    &gt;&gt;&gt; a = cg.play(game, n=3)
    &gt;&gt;&gt; b = cg.play(game[:1], n=3)

    &gt;&gt;&gt; a.picked
    array([[1, 1, 1],
           [1, 1, 1],
           [1, 1, 1]])

    &gt;&gt;&gt; b.picked
    array([[0, 0, 0],
           [0, 0, 0],
           [0, 0, 0]])

    # simple concatenation
    &gt;&gt;&gt; c = cg.combine_sims([a, b])
    &gt;&gt;&gt; type(c)
    cargoat.sim.MontyHallSim

    &gt;&gt;&gt; c.picked
    array([[1, 1, 1],
           [1, 1, 1],
           [1, 1, 1],
           [0, 0, 0],
           [0, 0, 0],
           [0, 0, 0]])

    # using index to interleave
    &gt;&gt;&gt; index = [0, 1, 0, 1, 0, 1]
    &gt;&gt;&gt; d = cg.combine_sims([a, b], index=index)
    &gt;&gt;&gt; d.picked
    array([[1, 1, 1],
           [0, 0, 0],
           [1, 1, 1],
           [0, 0, 0],
           [1, 1, 1],
           [0, 0, 0]])

    ```

    &#39;&#39;&#39;

    n = len(sims)
    rows = [x.shape[0] for x in sims]
    cols = [x.shape[1] for x in sims if not x.empty]
    copyfun = (lambda x: x.copy()) if copy else (lambda x: x)

    if len(set(cols)) != 1:
        raise ValueError(&#39;All sims must have the same number of doors (columns).&#39;)

    if index is None:
        index = np.repeat(np.arange(n, dtype=int), rows)

    if len(index) != sum(rows):
        raise ValueError(&#39;Index length must match number of trials across simulations.&#39;)

    shape = (len(index), cols[0])

    cars = np.zeros(shape, dtype=int)
    picked = np.zeros(shape, dtype=int)
    revealed = np.zeros(shape, dtype=int)
    spoiled = np.zeros(shape[0], dtype=bool)

    for i in np.unique(index):
        sim = sims[i]
        cars[index == i, :] = copyfun(sim.cars)
        picked[index == i, :] = copyfun(sim.picked)
        revealed[index == i, :] = copyfun(sim.revealed)
        spoiled[index == i] = sim.spoiled

    return MontyHallSim.from_arrays(picked=picked,
                                    revealed=revealed,
                                    cars=cars,
                                    spoiled=spoiled,
                                    copy=False)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cargoat.sim.MontyHallSim"><code class="flex name class">
<span>class <span class="ident">MontyHallSim</span></span>
<span>(</span><span>n)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for remembering the status of the game simualtion.</p>
<p>The MontyHallSim object tracks the game status for repeated Monty Hall
games.</p>
<p>Games are mainly recorded with numpy arrays.
There are three primary
arrays, stored as attributes:
- <code>self.picked</code>: Indicates doors selected by the player
- <code>self.revealed</code>: Indicates doors that have been opened
- <code>self.cars</code>: Indicates doors which have a car behind them.</p>
<p>These are all binary, 2D, integer arrays.
The shape of the arrays
during/after a typical simulation will be (trials, doors) - one row
constitutes one game.
The initialization argument <code>n</code> determines
the number of trials.
The number of doors is determined by the particular
game being played.</p>
<p>There is also a <code>spoiled</code> attribute, which is a boolean numpy array of
shape (trials,).
This simply records whether a trial has broken
the rules of the traditional Monty Hall game.</p>
<p>MontyHallSims are updated by applying rules/actions, i.e. from the
<code><a title="cargoat.actions" href="actions/index.html">cargoat.actions</a></code> subpackage.</p>
<p>Typically, a user <em>should not</em> have to manually define a MontyHallSim
object, as <code><a title="cargoat.core.play" href="core.html#cargoat.core.play">play()</a></code> will do this provided a list of actions.
<em>Initialization of a MontyHallSim results in an empty simulation</em> -
i.e. all the array attributes will be empty.
The actions in
<code><a title="cargoat.actions.initialization" href="actions/initialization.html">cargoat.actions.initialization</a></code> are intended for populating the
simulation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of trials to simulate.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MontyHallSim:
    &#39;&#39;&#39;Class for remembering the status of the game simualtion.&#39;&#39;&#39;

    # ---- Dunder methods

    def __init__(self, n):
        &#39;&#39;&#39;
        The MontyHallSim object tracks the game status for repeated Monty Hall
        games.

        Games are mainly recorded with numpy arrays.  There are three primary
        arrays, stored as attributes:
            - `self.picked`: Indicates doors selected by the player
            - `self.revealed`: Indicates doors that have been opened
            - `self.cars`: Indicates doors which have a car behind them.

        These are all binary, 2D, integer arrays.  The shape of the arrays
        during/after a typical simulation will be (trials, doors) - one row
        constitutes one game.  The initialization argument `n` determines
        the number of trials.  The number of doors is determined by the particular
        game being played.

        There is also a `spoiled` attribute, which is a boolean numpy array of
        shape (trials,).  This simply records whether a trial has broken
        the rules of the traditional Monty Hall game.

        MontyHallSims are updated by applying rules/actions, i.e. from the
        `cargoat.actions` subpackage.

        Typically, a user *should not* have to manually define a MontyHallSim
        object, as `cargoat.core.play` will do this provided a list of actions.
        *Initialization of a MontyHallSim results in an empty simulation* -
        i.e. all the array attributes will be empty.  The actions in
        `cargoat.actions.initialization` are intended for populating the
        simulation.


        Parameters
        ----------
        n : int
            Number of trials to simulate.

        Returns
        -------
        None.

        &#39;&#39;&#39;
        self.n = int(n)

        self.make_empty()

    def __eq__(self, sim):
        if not isinstance(sim, MontyHallSim):
            return False
        elif self.shape != sim.shape:
            return False
        else:
            return all([(self.cars == sim.cars).all(),
                        (self.picked == sim.picked).all(),
                        (self.revealed == sim.revealed).all(),
                        (self.spoiled == sim.spoiled).all(),
                        (self.n == sim.n)])

    # ---- Class methods

    @classmethod
    def from_arrays(cls, picked=None, revealed=None, cars=None,
                    spoiled=None, default=0, copy=True):
        &#39;&#39;&#39;
        Construct a MontyHallSim from existing numpy arrays.

        Parameters
        ----------
        picked : 2D numpy array, optional
            Integer array indicating picked doors. The default is None.
        revealed : 2D numpy array, optional
            Integer array indicating revealed doors. The default is None.
        cars : 2D numpy array, optional
            Integer array indicating doors containing cars. The default is None.
        spoiled : 1D numpy array, optional
            Boolean array indicating spoiled trials. The default is None.
        default : int, optional
            When only some of `picked`/`revealed`/`cars` are provided, use
            this value to fill the missing arrays. The default is 0.
        copy : bool, optional
            Call an explicit copy on the arrays before binding to the new
            simulation being created. Intended to prevent multiple simulations
            pointing to the same arrays.  The default is True.

        Raises
        ------
        ValueError
            - Didn&#39;t provide at least one of `cars`, `picked`, or `revealed`
            - Different array shapes for provided arrays.

        Returns
        -------
        out : MontyHallSim
            New simulation object.

        &#39;&#39;&#39;

        mainarrays = (cars, picked, revealed)

        if all([i is None for i in mainarrays]):
            raise ValueError(&#39;Must provide at least one of cars, &#39;
                             &#39;picked, or revealed.&#39;)

        base = [a for a in mainarrays if a is not None][0]
        shape = base.shape

        if picked is None:
            picked = np.full(shape, default)
        if revealed is None:
            revealed = np.full(shape, default)
        if cars is None:
            cars = np.full(shape, default)

        shape_set = set(i.shape for i in (cars, picked, revealed))

        if len(shape_set) != 1:
            raise ValueError(&#39;Detected different array shapes for &#39;
                             &#39;picked, revealed, and cars.&#39;)

        n, doors = shape
        if spoiled is None:
            spoiled = np.zeros(n, dtype=bool)
        if len(spoiled) != n:
            raise ValueError(&#39;spoiled array does not match&#39;)

        for a in (cars, picked, revealed, spoiled):
            uniq = np.unique(a)
            if any(u not in (0, 1) for u in uniq):
                msg = (&#34;Non-binary integer detected in incoming arrays.&#34;)
                warnings.warn(RuntimeWarning(msg))

        copyfun = (lambda x: x.copy()) if copy else (lambda x: x)

        out = cls(n)
        out.cars = copyfun(cars)
        out.picked = copyfun(picked)
        out.revealed = copyfun(revealed)
        out.spoiled = copyfun(spoiled)

        return out

    # ---- Properties
    @property
    def idx(self):
        &#39;&#39;&#39;Return a numpy arange of length `self.n`&#39;&#39;&#39;
        return np.arange(self.n)

    @property
    def shape(self):
        &#39;&#39;&#39;Return the dimensions of the simulation (trials, doors).  Throws an error if
        different array shapes are found.&#39;&#39;&#39;
        shape_set = set([self.cars.shape, self.picked.shape, self.revealed.shape])
        if len(shape_set) != 1:
            raise RuntimeError(&#39;Found different shapes for simulation arrays!&#39;)

        return self.picked.shape

    @property
    def empty(self):
        &#39;&#39;&#39;Determine if the sim is &#34;empty&#34; - this is the status it should
        have prior to applying any operations.&#39;&#39;&#39;
        arrs = [self.cars, self.picked, self.revealed, self.spoiled]
        return all(a.size == 0 for a in arrs)


    # ---- Initialization
    def init_doors(self, doors):
        &#39;&#39;&#39;Populate arrays with zeros.&#39;&#39;&#39;
        shape = (self.n, doors)
        self.cars = np.zeros(shape, dtype=int)
        self.picked = np.zeros(shape, dtype=int)
        self.revealed = np.zeros(shape, dtype=int)
        self.spoiled = np.zeros(self.n, dtype=bool)

    def make_empty(self):
        &#39;&#39;&#39;Save empty arrays into main arrays.&#39;&#39;&#39;
        self.cars = np.empty(0, dtype=int)
        self.picked = np.empty(0, dtype=int)
        self.revealed = np.empty(0, dtype=int)
        self.spoiled = np.empty(0, dtype=bool)

    # ---- Indexing
    def select(self, x=None, y=None, copy=True, use_ix_=True):
        &#39;&#39;&#39;
        Index the simulation to create a new one.

        Parameters
        ----------
        x : int, float, list-like, optional
            Indexer for trials (rows) of simulation. The default is None,
            in which case all trials are selected.
        y : int, float, list-like, optional
            Indexer for doors (columns) of simulation. The default is None,
            in which case all doors are selected.
        copy : bool, optional
            Create an explicit copy of the arrays before binding to the
            newly created simulation. The default is True.  Note that
            many indexing operations with this function trigger numpy advanced
            indexing and thus create copies of the main arrays.
            For now, copy is set to default and wastefully create more copies.
            This may be optimized in the future.
        use_ix_ : bool, optional
            Use `np.ix_` when passing `x` and `y`.  This is typically
            necessary for selecting doors and trials simultaneously -
            indexing both rows and columns is not as simple as passing
            `arr[x, y]`.

        Returns
        -------
        MontyHallSimulation
            New simulation object.

        &#39;&#39;&#39;
        # this prevents loss of dimension for selecting single doors
        x = [x] if isinstance(x, int) else x
        y = [y] if isinstance(y, int) else y

        # this allows for selection of trials and doors simulataneously
        if (x is not None and y is not None) and use_ix_:
            x, y = np.ix_(x, y)

        # this allows indexing of only one axis
        x = slice(None) if x is None else x
        y = slice(None) if y is None else y

        copyfun = (lambda x: x.copy()) if copy else (lambda x: x)

        cars = copyfun(self.cars[x, y])
        picked = copyfun(self.picked[x, y])
        revealed = copyfun(self.revealed[x, y])
        spoiled = copyfun(self.spoiled[x])

        return self.from_arrays(picked=picked,
                                revealed=revealed,
                                cars=cars,
                                spoiled=spoiled,
                                copy=False)


    # ---- Status of the sim
    def pickable_doors(self, exclude_current=True):
        &#39;&#39;&#39;Array of the simulation shape indicating which doors are
        not revealed (with or without the current picked doors).&#39;&#39;&#39;
        return ~self.query_doors_or(picked=exclude_current, revealed=True)

    def query_doors_or(self, cars=False, picked=False, revealed=False,
                       not_cars=False, not_picked=False, not_revealed=False):
        &#39;&#39;&#39;
        Return a boolean array indicating which doors of the simulation
        meet one or more conditions.

        Parameters
        ----------
        cars : bool, optional
            Signal doors containing cars. The default is False.
        picked : bool, optional
            Signal doors that are picked. The default is False.
        revealed : bool, optional
            Signal doors that are revealed. The default is False.
        not_cars : bool, optional
            Signal doors that do not contain cars. The default is False.
        not_picked : bool, optional
            Signal doors that are not picked. The default is False.
        not_revealed : bool, optional
            Signal doors that are closed. The default is False.

        Returns
        -------
        out : numpy array

        &#39;&#39;&#39;
        c = int(cars)
        p = int(picked)
        r = int(revealed)
        notc = int(not_cars)
        notp = int(not_picked)
        notr = int(not_revealed)

        out = np.logical_or.reduce([
            c * self.cars,
            p * self.picked,
            r * self.revealed,
            notc * (1 - self.cars),
            notp * (1 - self.picked),
            notr * (1 - self.revealed)
            ])
        return out

    def revealable_doors(self):
        &#39;&#39;&#39;Array of the simulation shape indicating which doors are
        not revealed, don&#39;t contain cars, and aren&#39;t currently picked.&#39;&#39;&#39;
        return ~self.query_doors_or(cars=True, picked=True, revealed=True)

    def count_totals(self, target):
        &#39;&#39;&#39;Return a count of the number of positives for each trial in the
        simulation.  Target is `cars`, `picked`, or `revealed`. &#39;&#39;&#39;
        arr = getattr(self, target)
        return arr.sum(axis=1)

    def show(self, start=0, end=10):
        &#39;&#39;&#39;Printout a representation of a selection of rows of the simulation.&#39;&#39;&#39;
        start = max(0, start)
        end = min(self.n, end)
        print(f&#39;Trials: {start}-{end-1}&#39;)
        print(&#39;\nCars:&#39;)
        print(self.cars[start:end, ])
        print(&#39;\nRevealed:&#39;)
        print(self.revealed[start:end, ])
        print(&#39;\nPicked:&#39;)
        print(self.picked[start:end, ])

    # ---- Generic setter functions

    def _get_spoiling_func(self, target):
        &#39;&#39;&#39;Helper to return the function used to detect spoiled games when
        applying certain actions.&#39;&#39;&#39;
        if target == &#39;picked&#39;:
            return self._check_spoiling_picks

        elif target == &#39;revealed&#39;:
            return self._check_spoiling_reveals

        elif target == &#39;cars&#39;:
            return self._check_spoiling_cars

        else:
            raise ValueError (&#39;Target must be &#34;picked&#34;, &#34;revealed&#34;, or &#34;cars&#34;&#39;)

    def _set_array(self, target, new_array,
                   behavior=&#39;overwrite&#39;, n_per_row=None, allow_spoiled=False,
                   allow_redundant=True):
        &#39;&#39;&#39;
        Main function for altering the cars, picked, and revealed arrays
        of the simulation when applying a action in the game.

        A new array is passed, along with a behavior defining how to
        treat the new array.  This information is used to determine
        how to update the simulation.

        Some optional checks can be applied to verify the settings
        are behaving as expected and that the traditional game rules
        are more/less followed.

        Parameters
        ----------
        target : &#39;cars&#39;, &#39;picked&#39;, or &#39;revealed&#39;
            Simulation array to set.
        new_array : numpy array
            New array to use to update the simulation
        behavior : &#39;overwrite&#39;, &#39;add&#39;, or &#39;remove&#39;, optional
            How to treat the `new_array`. The default is &#39;overwrite&#39;.
            - overwrite: `new_array` should simply replace the current target array.
            - add: any 1s in `new_array` should be added to any 1s in the current target
            array (essentially an &#34;or&#34; operation)
            - remove: any 1s in `new_array` should indicate places to remove 1s
            in the current array.
        n_per_row : int, optional
            Enforce that a certain number of 1s are present per row in `new_array`.
            The default is None, in which case there is no enforcement. An
            error is raised if the condition is not met.  See
            `cargoat.errors.check_n_per_row()`.
        allow_spoiled : bool, optional
            Allow entries in the new array that &#34;spoil&#34; the game; i.e. break
            the rules of the game. The specific checks are dependent on
            the `target` and the `behavior`.  The default is False.
            If False, spoiled games will raise an error.  If True,
            spoiled games will be marked in the `self.spoiled` attribute.
        allow_redundant : bool, optional
            Allow entries in the new array that are redundant with the
            current simulation, e.g. closing an already closed door or picking
            an already picked door.  The default is True.  If False,
            redundant actions will raise an error.

        Returns
        -------
        None.

        &#39;&#39;&#39;

        old_array = getattr(self, target)
        check_spoiling = self._get_spoiling_func(target)
        etype = {&#39;cars&#39;: BadCar,
                 &#39;revealed&#39;: BadReveal,
                 &#39;picked&#39;: BadPick}[target]

        if new_array.shape != self.shape:
            raise ValueError(f&#39;New array shape {new_array.shape} &#39;
                             f&#39;does not match current shape {self.shape}&#39;)

        # apply checks if requested
        if n_per_row is not None:
            check_n_per_row(a=new_array, n=n_per_row, etype=etype)

        if not allow_redundant:
            check_redundancy_for_setting(old_array=old_array, new_array=new_array,
                                         behavior=behavior, etype=etype)

        # then check for valid action
        kosher = check_spoiling(new_array, behavior=behavior, allow_spoiled=allow_spoiled)

        # mark spoiled games (only based on invalid picks)
        spoiling_rows = np.any(~kosher, axis=1)
        self.spoiled[spoiling_rows] = 1

        # update sim.picked
        if behavior == &#39;add&#39;:
            new_array = np.logical_or(new_array, old_array).astype(int)
        elif behavior == &#39;remove&#39;:
            new_array = old_array - np.logical_and(new_array, old_array).astype(int)
            new_array[new_array &lt; 0] = 0

        setattr(self, target, new_array)

    # ---- Pick setting

    def _check_spoiling_picks(self, picks, behavior, allow_spoiled=True):
        &#39;&#39;&#39;
        Checks if new picks spoil the game. Violations are when
        revealed doors are picked.  Removals (unpicking) do
        not trigger spoiling.
        &#39;&#39;&#39;
        if behavior in [&#39;add&#39;, &#39;overwrite&#39;]:
            valid =  ~ np.logical_and(self.revealed, picks)
        elif behavior == &#39;remove&#39;:
            valid = np.full(self.shape, True)

        if not allow_spoiled and np.any(~valid):
            invalid_rows = np.any(~valid, axis=1)
            trial, door = get_index_success(~valid)
            msg = (&#34;Revealed doors were picked, e.g. &#34;
                   f&#34;trial {trial} door {door}.&#34;)
            bad_trials_raise(invalid_rows, msg, BadPick)

        return valid

    # ---- Door revealing

    def _check_spoiling_reveals(self, reveals, behavior, allow_spoiled=True):
        &#39;&#39;&#39;
        Checks if new reveals spoil the game. Violations are when
        cars or picked foors are revealed.  Removals (closing) do
        not trigger spoiling.
        &#39;&#39;&#39;
        offlimits = self.query_doors_or(cars=True, picked=True)
        if behavior in [&#39;add&#39;, &#39;overwrite&#39;]:
            valid =  ~np.logical_and(offlimits, reveals)
        elif behavior == &#39;remove&#39;:
            valid = np.full(self.shape, True)

        if not allow_spoiled and np.any(~valid):
            invalid_rows = np.any(~valid, axis=1)
            trial, door = get_index_success(~valid)
            msg = (&#34;Cars or picked doors were revealed, e.g. &#34;
                   f&#34;trial {trial} door {door}.&#34;)
            bad_trials_raise(invalid_rows, msg, BadReveal)

        return valid

    # ---- Car placing
    def _check_spoiling_cars(self, cars, behavior, allow_spoiled=True):
        &#39;&#39;&#39;
        Checks if new car placements spoil the game. Car placement/removal
        is not really mentioned in the typical game variations.  For now
        altering the car array does not result in spoiled games.
        &#39;&#39;&#39;
        valid = np.full(self.shape, True)
        return valid

    # ---- Other Helpers
    def apply_func(self, func, inplace=False, cars=True, picked=True, revealed=True):
        &#39;&#39;&#39;
        Apply a function to one or more of the cars, picked, and revealed
        arrays.

        Parameters
        ----------
        func : callable
            Function to apply.
        inplace : bool, optional
            The function will modify the arrays in place. The default is False.
        cars : bool, optional
            Apply to the car array. The default is True.
        picked : bool, optional
            Apply to the picked array. The default is True.
        revealed : bool, optional
            Apply to the revealed array. The default is True.

        Returns
        -------
        None.

        &#39;&#39;&#39;
        apply_to = [x for i, x in enumerate([&#39;cars&#39;, &#39;picked&#39;, &#39;revealed&#39;])
                    if [cars, picked, revealed][i]]
        for attr in apply_to:
            a = getattr(self, attr)
            if inplace:
                func(a)
            else:
                setattr(self, attr, func(a))

    def copy(self):
        &#39;&#39;&#39;
        Create a copy of the current simulation.

        Returns
        -------
        MontyHallSim

        &#39;&#39;&#39;
        if self.empty:
            return MontyHallSim(self.n)
        else:
            return self.from_arrays(picked=self.picked,
                                    revealed=self.revealed,
                                    cars=self.cars,
                                    spoiled=self.spoiled,
                                    copy=True)

    # ---- Results

    def is_win(self):
        &#39;&#39;&#39;
        Return a boolean array indicating which trials are wins.  I.e.,
        at least one door with a car is picked.  Spoiled games have not
        bearing on this method
        &#39;&#39;&#39;
        return np.any(self.picked * self.cars, axis=1)

    def get_results(self, condition=None):
        &#39;&#39;&#39;
        Return a dictionary containing the game results,
        e.g. number of wins and losses.  Trials are counted
        as wins when at least one pick and car overlap, i.e.
        both have 1s in the same position.

        Parameters
        ----------
        condition :  callable or list-like
            A pre-computed 1D boolean arrray used to index the simulation.

        Returns
        -------
        None.

        &#39;&#39;&#39;


        sim = self.select(x=condition) if condition is not None else self

        wins = np.sum(np.any(sim.picked * sim.cars, axis=1))
        losses = sim.n - wins
        percent_wins = (wins / sim.n) * 100
        percent_losses = (losses / sim.n) * 100
        spoiled_games = np.any(sim.spoiled)
        results = {
            &#39;trials&#39;: sim.n,
            &#39;wins&#39;: wins,
            &#39;losses&#39;: losses,
            &#39;percent_wins&#39;: percent_wins,
            &#39;percent_losses&#39;: percent_losses,
            &#39;spoiled_games&#39;: spoiled_games
            }

        return results</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="cargoat.sim.MontyHallSim.from_arrays"><code class="name flex">
<span>def <span class="ident">from_arrays</span></span>(<span>picked=None, revealed=None, cars=None, spoiled=None, default=0, copy=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Construct a MontyHallSim from existing numpy arrays.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>picked</code></strong> :&ensp;<code>2D numpy array</code>, optional</dt>
<dd>Integer array indicating picked doors. The default is None.</dd>
<dt><strong><code>revealed</code></strong> :&ensp;<code>2D numpy array</code>, optional</dt>
<dd>Integer array indicating revealed doors. The default is None.</dd>
<dt><strong><code>cars</code></strong> :&ensp;<code>2D numpy array</code>, optional</dt>
<dd>Integer array indicating doors containing cars. The default is None.</dd>
<dt><strong><code>spoiled</code></strong> :&ensp;<code>1D numpy array</code>, optional</dt>
<dd>Boolean array indicating spoiled trials. The default is None.</dd>
<dt><strong><code>default</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>When only some of <code>picked</code>/<code>revealed</code>/<code>cars</code> are provided, use
this value to fill the missing arrays. The default is 0.</dd>
<dt><strong><code>copy</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Call an explicit copy on the arrays before binding to the new
simulation being created. Intended to prevent multiple simulations
pointing to the same arrays.
The default is True.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>
<ul>
<li>Didn't provide at least one of <code>cars</code>, <code>picked</code>, or <code>revealed</code></li>
<li>Different array shapes for provided arrays.</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>out</code></strong> :&ensp;<code><a title="cargoat.sim.MontyHallSim" href="#cargoat.sim.MontyHallSim">MontyHallSim</a></code></dt>
<dd>New simulation object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_arrays(cls, picked=None, revealed=None, cars=None,
                spoiled=None, default=0, copy=True):
    &#39;&#39;&#39;
    Construct a MontyHallSim from existing numpy arrays.

    Parameters
    ----------
    picked : 2D numpy array, optional
        Integer array indicating picked doors. The default is None.
    revealed : 2D numpy array, optional
        Integer array indicating revealed doors. The default is None.
    cars : 2D numpy array, optional
        Integer array indicating doors containing cars. The default is None.
    spoiled : 1D numpy array, optional
        Boolean array indicating spoiled trials. The default is None.
    default : int, optional
        When only some of `picked`/`revealed`/`cars` are provided, use
        this value to fill the missing arrays. The default is 0.
    copy : bool, optional
        Call an explicit copy on the arrays before binding to the new
        simulation being created. Intended to prevent multiple simulations
        pointing to the same arrays.  The default is True.

    Raises
    ------
    ValueError
        - Didn&#39;t provide at least one of `cars`, `picked`, or `revealed`
        - Different array shapes for provided arrays.

    Returns
    -------
    out : MontyHallSim
        New simulation object.

    &#39;&#39;&#39;

    mainarrays = (cars, picked, revealed)

    if all([i is None for i in mainarrays]):
        raise ValueError(&#39;Must provide at least one of cars, &#39;
                         &#39;picked, or revealed.&#39;)

    base = [a for a in mainarrays if a is not None][0]
    shape = base.shape

    if picked is None:
        picked = np.full(shape, default)
    if revealed is None:
        revealed = np.full(shape, default)
    if cars is None:
        cars = np.full(shape, default)

    shape_set = set(i.shape for i in (cars, picked, revealed))

    if len(shape_set) != 1:
        raise ValueError(&#39;Detected different array shapes for &#39;
                         &#39;picked, revealed, and cars.&#39;)

    n, doors = shape
    if spoiled is None:
        spoiled = np.zeros(n, dtype=bool)
    if len(spoiled) != n:
        raise ValueError(&#39;spoiled array does not match&#39;)

    for a in (cars, picked, revealed, spoiled):
        uniq = np.unique(a)
        if any(u not in (0, 1) for u in uniq):
            msg = (&#34;Non-binary integer detected in incoming arrays.&#34;)
            warnings.warn(RuntimeWarning(msg))

    copyfun = (lambda x: x.copy()) if copy else (lambda x: x)

    out = cls(n)
    out.cars = copyfun(cars)
    out.picked = copyfun(picked)
    out.revealed = copyfun(revealed)
    out.spoiled = copyfun(spoiled)

    return out</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="cargoat.sim.MontyHallSim.empty"><code class="name">var <span class="ident">empty</span></code></dt>
<dd>
<div class="desc"><p>Determine if the sim is "empty" - this is the status it should
have prior to applying any operations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def empty(self):
    &#39;&#39;&#39;Determine if the sim is &#34;empty&#34; - this is the status it should
    have prior to applying any operations.&#39;&#39;&#39;
    arrs = [self.cars, self.picked, self.revealed, self.spoiled]
    return all(a.size == 0 for a in arrs)</code></pre>
</details>
</dd>
<dt id="cargoat.sim.MontyHallSim.idx"><code class="name">var <span class="ident">idx</span></code></dt>
<dd>
<div class="desc"><p>Return a numpy arange of length <code>self.n</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def idx(self):
    &#39;&#39;&#39;Return a numpy arange of length `self.n`&#39;&#39;&#39;
    return np.arange(self.n)</code></pre>
</details>
</dd>
<dt id="cargoat.sim.MontyHallSim.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<div class="desc"><p>Return the dimensions of the simulation (trials, doors).
Throws an error if
different array shapes are found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self):
    &#39;&#39;&#39;Return the dimensions of the simulation (trials, doors).  Throws an error if
    different array shapes are found.&#39;&#39;&#39;
    shape_set = set([self.cars.shape, self.picked.shape, self.revealed.shape])
    if len(shape_set) != 1:
        raise RuntimeError(&#39;Found different shapes for simulation arrays!&#39;)

    return self.picked.shape</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="cargoat.sim.MontyHallSim.apply_func"><code class="name flex">
<span>def <span class="ident">apply_func</span></span>(<span>self, func, inplace=False, cars=True, picked=True, revealed=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply a function to one or more of the cars, picked, and revealed
arrays.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>func</code></strong> :&ensp;<code>callable</code></dt>
<dd>Function to apply.</dd>
<dt><strong><code>inplace</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>The function will modify the arrays in place. The default is False.</dd>
<dt><strong><code>cars</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Apply to the car array. The default is True.</dd>
<dt><strong><code>picked</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Apply to the picked array. The default is True.</dd>
<dt><strong><code>revealed</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Apply to the revealed array. The default is True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_func(self, func, inplace=False, cars=True, picked=True, revealed=True):
    &#39;&#39;&#39;
    Apply a function to one or more of the cars, picked, and revealed
    arrays.

    Parameters
    ----------
    func : callable
        Function to apply.
    inplace : bool, optional
        The function will modify the arrays in place. The default is False.
    cars : bool, optional
        Apply to the car array. The default is True.
    picked : bool, optional
        Apply to the picked array. The default is True.
    revealed : bool, optional
        Apply to the revealed array. The default is True.

    Returns
    -------
    None.

    &#39;&#39;&#39;
    apply_to = [x for i, x in enumerate([&#39;cars&#39;, &#39;picked&#39;, &#39;revealed&#39;])
                if [cars, picked, revealed][i]]
    for attr in apply_to:
        a = getattr(self, attr)
        if inplace:
            func(a)
        else:
            setattr(self, attr, func(a))</code></pre>
</details>
</dd>
<dt id="cargoat.sim.MontyHallSim.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a copy of the current simulation.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="cargoat.sim.MontyHallSim" href="#cargoat.sim.MontyHallSim">MontyHallSim</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    &#39;&#39;&#39;
    Create a copy of the current simulation.

    Returns
    -------
    MontyHallSim

    &#39;&#39;&#39;
    if self.empty:
        return MontyHallSim(self.n)
    else:
        return self.from_arrays(picked=self.picked,
                                revealed=self.revealed,
                                cars=self.cars,
                                spoiled=self.spoiled,
                                copy=True)</code></pre>
</details>
</dd>
<dt id="cargoat.sim.MontyHallSim.count_totals"><code class="name flex">
<span>def <span class="ident">count_totals</span></span>(<span>self, target)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a count of the number of positives for each trial in the
simulation.
Target is <code>cars</code>, <code>picked</code>, or <code>revealed</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def count_totals(self, target):
    &#39;&#39;&#39;Return a count of the number of positives for each trial in the
    simulation.  Target is `cars`, `picked`, or `revealed`. &#39;&#39;&#39;
    arr = getattr(self, target)
    return arr.sum(axis=1)</code></pre>
</details>
</dd>
<dt id="cargoat.sim.MontyHallSim.get_results"><code class="name flex">
<span>def <span class="ident">get_results</span></span>(<span>self, condition=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a dictionary containing the game results,
e.g. number of wins and losses.
Trials are counted
as wins when at least one pick and car overlap, i.e.
both have 1s in the same position.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>condition</code></strong> :&ensp;<code> callable</code> or <code>list-like</code></dt>
<dd>A pre-computed 1D boolean arrray used to index the simulation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_results(self, condition=None):
    &#39;&#39;&#39;
    Return a dictionary containing the game results,
    e.g. number of wins and losses.  Trials are counted
    as wins when at least one pick and car overlap, i.e.
    both have 1s in the same position.

    Parameters
    ----------
    condition :  callable or list-like
        A pre-computed 1D boolean arrray used to index the simulation.

    Returns
    -------
    None.

    &#39;&#39;&#39;


    sim = self.select(x=condition) if condition is not None else self

    wins = np.sum(np.any(sim.picked * sim.cars, axis=1))
    losses = sim.n - wins
    percent_wins = (wins / sim.n) * 100
    percent_losses = (losses / sim.n) * 100
    spoiled_games = np.any(sim.spoiled)
    results = {
        &#39;trials&#39;: sim.n,
        &#39;wins&#39;: wins,
        &#39;losses&#39;: losses,
        &#39;percent_wins&#39;: percent_wins,
        &#39;percent_losses&#39;: percent_losses,
        &#39;spoiled_games&#39;: spoiled_games
        }

    return results</code></pre>
</details>
</dd>
<dt id="cargoat.sim.MontyHallSim.init_doors"><code class="name flex">
<span>def <span class="ident">init_doors</span></span>(<span>self, doors)</span>
</code></dt>
<dd>
<div class="desc"><p>Populate arrays with zeros.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_doors(self, doors):
    &#39;&#39;&#39;Populate arrays with zeros.&#39;&#39;&#39;
    shape = (self.n, doors)
    self.cars = np.zeros(shape, dtype=int)
    self.picked = np.zeros(shape, dtype=int)
    self.revealed = np.zeros(shape, dtype=int)
    self.spoiled = np.zeros(self.n, dtype=bool)</code></pre>
</details>
</dd>
<dt id="cargoat.sim.MontyHallSim.is_win"><code class="name flex">
<span>def <span class="ident">is_win</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a boolean array indicating which trials are wins.
I.e.,
at least one door with a car is picked.
Spoiled games have not
bearing on this method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_win(self):
    &#39;&#39;&#39;
    Return a boolean array indicating which trials are wins.  I.e.,
    at least one door with a car is picked.  Spoiled games have not
    bearing on this method
    &#39;&#39;&#39;
    return np.any(self.picked * self.cars, axis=1)</code></pre>
</details>
</dd>
<dt id="cargoat.sim.MontyHallSim.make_empty"><code class="name flex">
<span>def <span class="ident">make_empty</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Save empty arrays into main arrays.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_empty(self):
    &#39;&#39;&#39;Save empty arrays into main arrays.&#39;&#39;&#39;
    self.cars = np.empty(0, dtype=int)
    self.picked = np.empty(0, dtype=int)
    self.revealed = np.empty(0, dtype=int)
    self.spoiled = np.empty(0, dtype=bool)</code></pre>
</details>
</dd>
<dt id="cargoat.sim.MontyHallSim.pickable_doors"><code class="name flex">
<span>def <span class="ident">pickable_doors</span></span>(<span>self, exclude_current=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Array of the simulation shape indicating which doors are
not revealed (with or without the current picked doors).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pickable_doors(self, exclude_current=True):
    &#39;&#39;&#39;Array of the simulation shape indicating which doors are
    not revealed (with or without the current picked doors).&#39;&#39;&#39;
    return ~self.query_doors_or(picked=exclude_current, revealed=True)</code></pre>
</details>
</dd>
<dt id="cargoat.sim.MontyHallSim.query_doors_or"><code class="name flex">
<span>def <span class="ident">query_doors_or</span></span>(<span>self, cars=False, picked=False, revealed=False, not_cars=False, not_picked=False, not_revealed=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a boolean array indicating which doors of the simulation
meet one or more conditions.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cars</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Signal doors containing cars. The default is False.</dd>
<dt><strong><code>picked</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Signal doors that are picked. The default is False.</dd>
<dt><strong><code>revealed</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Signal doors that are revealed. The default is False.</dd>
<dt><strong><code>not_cars</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Signal doors that do not contain cars. The default is False.</dd>
<dt><strong><code>not_picked</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Signal doors that are not picked. The default is False.</dd>
<dt><strong><code>not_revealed</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Signal doors that are closed. The default is False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>out</code></strong> :&ensp;<code>numpy array</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def query_doors_or(self, cars=False, picked=False, revealed=False,
                   not_cars=False, not_picked=False, not_revealed=False):
    &#39;&#39;&#39;
    Return a boolean array indicating which doors of the simulation
    meet one or more conditions.

    Parameters
    ----------
    cars : bool, optional
        Signal doors containing cars. The default is False.
    picked : bool, optional
        Signal doors that are picked. The default is False.
    revealed : bool, optional
        Signal doors that are revealed. The default is False.
    not_cars : bool, optional
        Signal doors that do not contain cars. The default is False.
    not_picked : bool, optional
        Signal doors that are not picked. The default is False.
    not_revealed : bool, optional
        Signal doors that are closed. The default is False.

    Returns
    -------
    out : numpy array

    &#39;&#39;&#39;
    c = int(cars)
    p = int(picked)
    r = int(revealed)
    notc = int(not_cars)
    notp = int(not_picked)
    notr = int(not_revealed)

    out = np.logical_or.reduce([
        c * self.cars,
        p * self.picked,
        r * self.revealed,
        notc * (1 - self.cars),
        notp * (1 - self.picked),
        notr * (1 - self.revealed)
        ])
    return out</code></pre>
</details>
</dd>
<dt id="cargoat.sim.MontyHallSim.revealable_doors"><code class="name flex">
<span>def <span class="ident">revealable_doors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Array of the simulation shape indicating which doors are
not revealed, don't contain cars, and aren't currently picked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def revealable_doors(self):
    &#39;&#39;&#39;Array of the simulation shape indicating which doors are
    not revealed, don&#39;t contain cars, and aren&#39;t currently picked.&#39;&#39;&#39;
    return ~self.query_doors_or(cars=True, picked=True, revealed=True)</code></pre>
</details>
</dd>
<dt id="cargoat.sim.MontyHallSim.select"><code class="name flex">
<span>def <span class="ident">select</span></span>(<span>self, x=None, y=None, copy=True, use_ix_=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Index the simulation to create a new one.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>int, float, list-like</code>, optional</dt>
<dd>Indexer for trials (rows) of simulation. The default is None,
in which case all trials are selected.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>int, float, list-like</code>, optional</dt>
<dd>Indexer for doors (columns) of simulation. The default is None,
in which case all doors are selected.</dd>
<dt><strong><code>copy</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Create an explicit copy of the arrays before binding to the
newly created simulation. The default is True.
Note that
many indexing operations with this function trigger numpy advanced
indexing and thus create copies of the main arrays.
For now, copy is set to default and wastefully create more copies.
This may be optimized in the future.</dd>
<dt><strong><code>use_ix_</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Use <code>np.ix_</code> when passing <code>x</code> and <code>y</code>.
This is typically
necessary for selecting doors and trials simultaneously -
indexing both rows and columns is not as simple as passing
<code>arr[x, y]</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>MontyHallSimulation</code></dt>
<dd>New simulation object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select(self, x=None, y=None, copy=True, use_ix_=True):
    &#39;&#39;&#39;
    Index the simulation to create a new one.

    Parameters
    ----------
    x : int, float, list-like, optional
        Indexer for trials (rows) of simulation. The default is None,
        in which case all trials are selected.
    y : int, float, list-like, optional
        Indexer for doors (columns) of simulation. The default is None,
        in which case all doors are selected.
    copy : bool, optional
        Create an explicit copy of the arrays before binding to the
        newly created simulation. The default is True.  Note that
        many indexing operations with this function trigger numpy advanced
        indexing and thus create copies of the main arrays.
        For now, copy is set to default and wastefully create more copies.
        This may be optimized in the future.
    use_ix_ : bool, optional
        Use `np.ix_` when passing `x` and `y`.  This is typically
        necessary for selecting doors and trials simultaneously -
        indexing both rows and columns is not as simple as passing
        `arr[x, y]`.

    Returns
    -------
    MontyHallSimulation
        New simulation object.

    &#39;&#39;&#39;
    # this prevents loss of dimension for selecting single doors
    x = [x] if isinstance(x, int) else x
    y = [y] if isinstance(y, int) else y

    # this allows for selection of trials and doors simulataneously
    if (x is not None and y is not None) and use_ix_:
        x, y = np.ix_(x, y)

    # this allows indexing of only one axis
    x = slice(None) if x is None else x
    y = slice(None) if y is None else y

    copyfun = (lambda x: x.copy()) if copy else (lambda x: x)

    cars = copyfun(self.cars[x, y])
    picked = copyfun(self.picked[x, y])
    revealed = copyfun(self.revealed[x, y])
    spoiled = copyfun(self.spoiled[x])

    return self.from_arrays(picked=picked,
                            revealed=revealed,
                            cars=cars,
                            spoiled=spoiled,
                            copy=False)</code></pre>
</details>
</dd>
<dt id="cargoat.sim.MontyHallSim.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self, start=0, end=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Printout a representation of a selection of rows of the simulation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show(self, start=0, end=10):
    &#39;&#39;&#39;Printout a representation of a selection of rows of the simulation.&#39;&#39;&#39;
    start = max(0, start)
    end = min(self.n, end)
    print(f&#39;Trials: {start}-{end-1}&#39;)
    print(&#39;\nCars:&#39;)
    print(self.cars[start:end, ])
    print(&#39;\nRevealed:&#39;)
    print(self.revealed[start:end, ])
    print(&#39;\nPicked:&#39;)
    print(self.picked[start:end, ])</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cargoat" href="index.html">cargoat</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="cargoat.sim.combine_sims" href="#cargoat.sim.combine_sims">combine_sims</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cargoat.sim.MontyHallSim" href="#cargoat.sim.MontyHallSim">MontyHallSim</a></code></h4>
<ul class="two-column">
<li><code><a title="cargoat.sim.MontyHallSim.apply_func" href="#cargoat.sim.MontyHallSim.apply_func">apply_func</a></code></li>
<li><code><a title="cargoat.sim.MontyHallSim.copy" href="#cargoat.sim.MontyHallSim.copy">copy</a></code></li>
<li><code><a title="cargoat.sim.MontyHallSim.count_totals" href="#cargoat.sim.MontyHallSim.count_totals">count_totals</a></code></li>
<li><code><a title="cargoat.sim.MontyHallSim.empty" href="#cargoat.sim.MontyHallSim.empty">empty</a></code></li>
<li><code><a title="cargoat.sim.MontyHallSim.from_arrays" href="#cargoat.sim.MontyHallSim.from_arrays">from_arrays</a></code></li>
<li><code><a title="cargoat.sim.MontyHallSim.get_results" href="#cargoat.sim.MontyHallSim.get_results">get_results</a></code></li>
<li><code><a title="cargoat.sim.MontyHallSim.idx" href="#cargoat.sim.MontyHallSim.idx">idx</a></code></li>
<li><code><a title="cargoat.sim.MontyHallSim.init_doors" href="#cargoat.sim.MontyHallSim.init_doors">init_doors</a></code></li>
<li><code><a title="cargoat.sim.MontyHallSim.is_win" href="#cargoat.sim.MontyHallSim.is_win">is_win</a></code></li>
<li><code><a title="cargoat.sim.MontyHallSim.make_empty" href="#cargoat.sim.MontyHallSim.make_empty">make_empty</a></code></li>
<li><code><a title="cargoat.sim.MontyHallSim.pickable_doors" href="#cargoat.sim.MontyHallSim.pickable_doors">pickable_doors</a></code></li>
<li><code><a title="cargoat.sim.MontyHallSim.query_doors_or" href="#cargoat.sim.MontyHallSim.query_doors_or">query_doors_or</a></code></li>
<li><code><a title="cargoat.sim.MontyHallSim.revealable_doors" href="#cargoat.sim.MontyHallSim.revealable_doors">revealable_doors</a></code></li>
<li><code><a title="cargoat.sim.MontyHallSim.select" href="#cargoat.sim.MontyHallSim.select">select</a></code></li>
<li><code><a title="cargoat.sim.MontyHallSim.shape" href="#cargoat.sim.MontyHallSim.shape">shape</a></code></li>
<li><code><a title="cargoat.sim.MontyHallSim.show" href="#cargoat.sim.MontyHallSim.show">show</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>